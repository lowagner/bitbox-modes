#include "nonsimple.h"

#include <stdint.h>
#include <bitbox.h>
#include <stdlib.h> // abs
#include <string.h> // memset

#define FASTMEM __attribute__ ((section (".ccm")))

struct vertical v[SCREEN_W][MAX_V] FASTMEM;
uint8_t v_index[SCREEN_W] FASTMEM; 
uint16_t palette[256] FASTMEM; 

const uint16_t initial_palette[] = { // 256 colors standard VGA palette
	// XXX replace with micro palette
	0x0000, 0x0015, 0x02a0, 0x02b5, 0x5400, 0x5415, 0x5540, 0x56b5, 
	0x294a, 0x295f, 0x2bea, 0x2bff, 0x7d4a, 0x7d5f, 0x7fea, 0x7fff, 
	0x0000, 0x0842, 0x1084, 0x14a5, 0x1ce7, 0x2108, 0x294a, 0x318c, 
	0x39ce, 0x4210, 0x4a52, 0x5294, 0x5ad6, 0x6739, 0x739c, 0x7fff, 
	0x001f, 0x201f, 0x3c1f, 0x5c1f, 0x7c1f, 0x7c17, 0x7c0f, 0x7c08, 
	0x7c00, 0x7d00, 0x7de0, 0x7ee0, 0x7fe0, 0x5fe0, 0x3fe0, 0x23e0, 
	0x03e0, 0x03e8, 0x03ef, 0x03f7, 0x03ff, 0x02ff, 0x01ff, 0x011f, 
	0x3dff, 0x4dff, 0x5dff, 0x6dff, 0x7dff, 0x7dfb, 0x7df7, 0x7df3, 
	0x7def, 0x7e6f, 0x7eef, 0x7f6f, 0x7fef, 0x6fef, 0x5fef, 0x4fef, 
	0x3fef, 0x3ff3, 0x3ff7, 0x3ffb, 0x3fff, 0x3f7f, 0x3eff, 0x3e7f, 
	0x5adf, 0x62df, 0x6edf, 0x76df, 0x7edf, 0x7edd, 0x7edb, 0x7ed8, 
	0x7ed6, 0x7f16, 0x7f76, 0x7fb6, 0x7ff6, 0x77f6, 0x6ff6, 0x63f6, 
	0x5bf6, 0x5bf8, 0x5bfb, 0x5bfd, 0x5bff, 0x5bbf, 0x5b7f, 0x5b1f, 
	0x000e, 0x0c0e, 0x1c0e, 0x280e, 0x380e, 0x380a, 0x3807, 0x3803, 
	0x3800, 0x3860, 0x38e0, 0x3940, 0x39c0, 0x29c0, 0x1dc0, 0x0dc0, 
	0x01c0, 0x01c3, 0x01c7, 0x01ca, 0x01ce, 0x014e, 0x00ee, 0x006e, 
	0x1cee, 0x20ee, 0x28ee, 0x30ee, 0x38ee, 0x38ec, 0x38ea, 0x38e8, 
	0x38e7, 0x3907, 0x3947, 0x3987, 0x39c7, 0x31c7, 0x29c7, 0x21c7, 
	0x1dc7, 0x1dc8, 0x1dca, 0x1dcc, 0x1dce, 0x1d8e, 0x1d4e, 0x1d0e, 
	0x294e, 0x2d4e, 0x314e, 0x354e, 0x394e, 0x394d, 0x394c, 0x394b, 
	0x394a, 0x396a, 0x398a, 0x39aa, 0x39ca, 0x35ca, 0x31ca, 0x2dca, 
	0x29ca, 0x29cb, 0x29cc, 0x29cd, 0x29ce, 0x29ae, 0x298e, 0x296e, 
	0x0008, 0x0808, 0x1008, 0x1808, 0x2008, 0x2006, 0x2004, 0x2002, 
	0x2000, 0x2040, 0x2080, 0x20c0, 0x2100, 0x1900, 0x1100, 0x0900, 
	0x0100, 0x0102, 0x0104, 0x0106, 0x0108, 0x00c8, 0x0088, 0x0048, 
	0x1088, 0x1488, 0x1888, 0x1c88, 0x2088, 0x2087, 0x2086, 0x2085, 
	0x2084, 0x20a4, 0x20c4, 0x20e4, 0x2104, 0x1d04, 0x1904, 0x1504, 
	0x1104, 0x1105, 0x1106, 0x1107, 0x1108, 0x10e8, 0x10c8, 0x10a8, 
	0x14a8, 0x18a8, 0x18a8, 0x1ca8, 0x20a8, 0x20a7, 0x20a6, 0x20a6, 
	0x20a5, 0x20c5, 0x20c5, 0x20e5, 0x2105, 0x1d05, 0x1905, 0x1905, 
	0x1505, 0x1506, 0x1506, 0x1507, 0x1508, 0x14e8, 0x14c8, 0x14c8, 
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};


void graph_frame() 
{
}
// --------------------------------------------------------------

void graph_line() 
{
    if (vga_odd)
        return;

    uint16_t *dst = draw_buffer;

    uint8_t vga8 = (uint8_t) vga_line;
    switch (vga8)
    {
    case 0:
        // need to run all the colors through...
        for (int i=0; i<SCREEN_W; ++i) 
        {
            v_index[i] = 0; // would need to be 1 according to lines 2 through SCREEN_H, but we can be more efficient here and check at line 1 for stuff, too
            *dst++ = palette[v[i][0].color];
        }
        return;
    case 1:
        // need to run all the colors through for double buffering
        for (int i=0; i<SCREEN_W; ++i) 
        {
            if (vga8 >= v[i][1].y)
            {
                *dst++ = palette[v[i][1].color];
                v_index[i] = 3; // encode the fact that we need to double buffer here
            }
            else
                // no need to double buffer
                *dst++ = palette[v[i][0].color];
        }
        return;
    }

    for (int i=0; i<SCREEN_W; ++i)
    {
        if (v_index[i] % 2) // odd guy, may need to double buffer what happened last line
        {
            if (v_index[i]/2 < MAX_V-1 && vga8 >= v[i][v_index[i]/2+1].y)
            {
                // but there's a new color, so don't repeat old color
                *dst = palette[v[i][v_index[i]/2+1].color];
                v_index[i] += 2;
            }
            else
            {
                // there's no old color...
                *dst = palette[v[i][v_index[i]/2].color];
                // make it even, but don't increase the color
                --v_index[i];
            }
        }
        else // odd, no need to re-double what happened
        {
            // but do need to add in a color if necessary
            if (v_index[i]/2 < MAX_V-1 && vga8 >= v[i][v_index[i]/2+1].y)
            {
                *dst = palette[v[i][v_index[i]/2+1].color];
                v_index[i] += 3;
            }

        }
        dst++;
    }
}
// --------------------------------------------------------------
// utilities 

void clear() 
{
   memcpy(palette,initial_palette,sizeof(initial_palette));
}

